// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "y(i) = A(i, j) * x(j)" -f=y:d -f=A:ds -f=x:d -write-assembly=assemble.hpp -write-compute=compute.hpp

#if defined(USE_BASELINE)
#include <functional>
#include <taskparts/benchmark.hpp>
#elif defined(USE_OPENMP)
#include "utility.hpp"
#elif defined(USE_HB_COMPILER) || defined(USE_HB_MANUAL)
#include "loop_handler.hpp"
#endif

#if defined(TEST_CORRECTNESS)
#include "taco.h"
using namespace taco;
#endif

#if defined(USE_BASELINE) || defined(TEST_CORRECTNESS)
void SPMV_baseline(
  int A1_dimension,
  int* __restrict__ A2_pos,
  int* __restrict__ A2_crd,
  double* __restrict__ A_vals,
  double* __restrict__ x_vals,
  double* __restrict__ y_vals
)  {
  for (int32_t i = 0; i < A1_dimension; i++) {
    double tjy_val = 0.0;
    for (int32_t jA = A2_pos[i]; jA < A2_pos[(i + 1)]; jA++) {
      int32_t j = A2_crd[jA];
      tjy_val += A_vals[jA] * x_vals[j];
    }
    y_vals[i] = tjy_val;
  }
}
#if defined(TEST_CORRECTNESS)
void test_correctness(taco_tensor_t *y, taco_tensor_t *A, taco_tensor_t *x) {
  Format d({Dense});
  Tensor<double> y_ref({A->dimensions[0]}, d);
  y_ref.pack();

  taco_tensor_t *y_ref_taco = y_ref.getTacoTensorT();
  assemble(y_ref_taco, y_ref_taco, y_ref_taco);

  int y1_dimension = (int)(y->dimensions[0]);
  double* __restrict__ y_vals = (double*)(y->vals);
  double* __restrict__ y_ref_vals = (double*)(y_ref_taco->vals);
  int A1_dimension = (int)(A->dimensions[0]);
  int* __restrict__ A2_pos = (int*)(A->indices[1][0]);
  int* __restrict__ A2_crd = (int*)(A->indices[1][1]);
  double* __restrict__ A_vals = (double*)(A->vals);
  int x1_dimension = (int)(x->dimensions[0]);
  double* __restrict__ x_vals = (double*)(x->vals);

  SPMV_baseline(A1_dimension, A2_pos, A2_crd, A_vals, x_vals, y_ref_vals);

  uint64_t num_diffs = 0;
  double epsilon = 0.01;
  for (int32_t i = 0; i < A1_dimension; i++) {
    auto diff = std::abs(y_vals[i] - y_ref_vals[i]);
    if (diff > epsilon) {
      printf("diff=%f y_vals[i]=%f y_ref_vals[i]=%f at i=%d\n", diff, y_vals[i], y_ref_vals[i], i);
      num_diffs++;
    }
  }
  if (num_diffs > 0) {
    printf("\033[0;31mINCORRECT!\033[0m");
    printf("  num_diffs = %lu\n", num_diffs);
  } else {
    printf("\033[0;32mCORRECT!\033[0m\n");
  }
}
#endif
#endif

#if defined(USE_OPENMP)
void SPMV_openmp(
  int A1_dimension,
  int* __restrict__ A2_pos,
  int* __restrict__ A2_crd,
  double* __restrict__ A_vals,
  double* __restrict__ x_vals,
  double* __restrict__ y_vals
) {
#if defined(OMP_SCHEDULE_STATIC)
  #pragma omp parallel for schedule(static)
#elif defined(OMP_SCHEDULE_DYNAMIC)
  #pragma omp parallel for schedule(dynamic)
#elif defined(OMP_SCHEDULE_GUIDED)
  #pragma omp parallel for schedule(guided)
#endif
  for (int32_t i = 0; i < A1_dimension; i++) {
    double tjy_val = 0.0;
    for (int32_t jA = A2_pos[i]; jA < A2_pos[(i + 1)]; jA++) {
      int32_t j = A2_crd[jA];
      tjy_val += A_vals[jA] * x_vals[j];
    }
    y_vals[i] = tjy_val;
  }
}
#elif defined(USE_HB_COMPILER)
#if defined(RUN_HEARTBEAT)
  bool run_heartbeat = true;
#else
  bool run_heartbeat = false;
#endif

double HEARTBEAT_loop1(
  uint64_t startIter,
  uint64_t maxIter,
  int* __restrict__ A2_crd,
  double* __restrict__ A_vals,
  double* __restrict__ x_vals
) {
    double tjy_val = 0.0;
    for (uint64_t jA = startIter; jA < maxIter; jA++) {
      int32_t j = A2_crd[jA];
      tjy_val += A_vals[jA] * x_vals[j];
    }
    return tjy_val;
}

void HEARTBEAT_loop0(
  uint64_t A1_dimension,
  int* __restrict__ A2_pos,
  int* __restrict__ A2_crd,
  double* __restrict__ A_vals,
  double* __restrict__ x_vals,
  double* __restrict__ y_vals
) {
  for (uint64_t i = 0; i < A1_dimension; i++) {
    double tjy_val = 0.0;
    tjy_val += HEARTBEAT_loop1(A2_pos[i], A2_pos[(i + 1)], A2_crd, A_vals, x_vals);
    y_vals[i] = tjy_val;
  }
}

void SPMV_hbc(
  int A1_dimension,
  int* __restrict__ A2_pos,
  int* __restrict__ A2_crd,
  double* __restrict__ A_vals,
  double* __restrict__ x_vals,
  double* __restrict__ y_vals
) {
  HEARTBEAT_loop0((uint64_t)A1_dimension, A2_pos, A2_crd, A_vals, x_vals, y_vals);
}

#elif defined(USE_HB_MANUAL)
#include "compute_hbm.hpp"
#endif

int compute(taco_tensor_t *y, taco_tensor_t *A, taco_tensor_t *x) {
  int y1_dimension = (int)(y->dimensions[0]);
  // double* __restrict__ y_vals = (double*)(y->vals);
  double* __restrict__ y_vals = (double*)malloc(10 * sizeof(double) * y1_dimension);
  int A1_dimension = (int)(A->dimensions[0]);
  int* __restrict__ A2_pos = (int*)(A->indices[1][0]);
  int* __restrict__ A2_crd = (int*)(A->indices[1][1]);
  double* __restrict__ A_vals = (double*)(A->vals);
  int x1_dimension = (int)(x->dimensions[0]);
  double* __restrict__ x_vals = (double*)(x->vals);

#if defined(USE_BASELINE)
  taskparts::benchmark_nativeforkjoin([&] (auto sched) {
#elif defined(USE_OPENMP)
  utility::run([&] {
#elif defined(USE_HB_COMPILER) || defined(USE_HB_MANUAL)
  run_bench([&] {
#endif
  // settings for benchmarking
  // for (int i = 0; i < 10000; i++) {
  for (int i = 0; i < 10; i++) {
#if defined(USE_BASELINE)
    SPMV_baseline(A1_dimension, A2_pos, A2_crd, A_vals, x_vals, y_vals + i * y1_dimension);
#elif defined(USE_OPENMP)
    SPMV_openmp(A1_dimension, A2_pos, A2_crd, A_vals, x_vals, y_vals + i * y1_dimension);
#elif defined(USE_HB_COMPILER)
    SPMV_hbc(A1_dimension, A2_pos, A2_crd, A_vals, x_vals, y_vals + i * y1_dimension);
#elif defined(USE_HB_MANUAL)
    SPMV_hbm(A1_dimension, A2_pos, A2_crd, A_vals, x_vals, y_vals + i * y1_dimension);
#endif
  }

#if defined(TEST_CORRECTNESS)
    test_correctness(y, A, x);
#endif

#if defined(USE_BASELINE)
  }, [&] (auto sched) {
  }, [&] (auto sched) {
  });
#else
  }, [&] {}, [&] {});
#endif

  return 0;
}
