// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "A(i, j) = B(i, k, l) * C(k, j) * D(l, j)" -f=A:dd -f=B:dss -f=C:dd -f=D:dd -write-assembly=assemble.hpp -write-compute=compute.hpp
// clang++ -std=c++17 -O3 -DNDEBUG -DTACO -I ../../include -L../../build/lib MTTKRP.cpp -o main -ltaco

#include <random>
#include "taco.h"
#include "assemble.hpp"
#include "compute.hpp"

using namespace taco;
int main(int argc, char* argv[]) {
  std::default_random_engine gen(0);
  std::uniform_real_distribution<double> unif(0.0, 1.0);

  Format dd({Dense, Dense});
  Format dss({Dense, Sparse, Sparse});

  Tensor<double> B = read("nell-2.tns", dss);
  for (auto dim : B.getDimensions()) {
    printf("dim = %d\n", dim);
  }

  Tensor<double> C({B.getDimension(1), 128}, dd);
  for (int i = 0; i < C.getDimension(0); ++i) {
    for (int j = 0; j < C.getDimension(1); ++j) {
      C.insert({i, j}, unif(gen));
    }
  }
  C.pack();

  Tensor<double> D({B.getDimension(2), 128}, dd);
  for (int i = 0; i < D.getDimension(0); ++i) {
    for (int j = 0; j < D.getDimension(1); ++j) {
      C.insert({i, j}, unif(gen));
    }
  }
  D.pack();

  Tensor<double> A({B.getDimension(0), B.getDimension(1)}, dd);
  A.pack();

  assemble(A.getTacoTensorT(), B.getTacoTensorT(), C.getTacoTensorT(), D.getTacoTensorT());
  compute(A.getTacoTensorT(), B.getTacoTensorT(), C.getTacoTensorT(), D.getTacoTensorT());

  return 0;
}
