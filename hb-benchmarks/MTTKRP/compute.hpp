// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "A(i, j) = B(i, k, l) * C(k, j) * D(l, j)" -f=A:dd -f=B:dss -f=C:dd -f=D:dd -write-assembly=assemble.hpp -write-compute=compute.hpp

#if defined(USE_BASELINE) || defined(USE_FORKJOIN)
#include <functional>
#include <taskparts/benchmark.hpp>
#elif defined(USE_OPENMP)
#include "utility.hpp"
#elif defined(USE_HB_COMPILER) || defined(USE_HB_MANUAL)
#include "loop_handler.hpp"
#endif

#if defined(TEST_CORRECTNESS)
#include "taco.h"
using namespace taco;
#endif

#if defined(USE_BASELINE) || defined(TEST_CORRECTNESS)
void MTTKRP_baseline(
  int B1_dimension,
  int* __restrict__ B2_pos,
  int* __restrict__ B2_crd,
  int* __restrict__ B3_pos,
  int* __restrict__ B3_crd,
  int D2_dimension,
  int A2_dimension,
  int C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
  for (uint64_t i = 0; i < B1_dimension; i++) {
    for (uint64_t kB = B2_pos[i]; kB < B2_pos[(i + 1)]; kB++) {
      uint64_t k = B2_crd[kB];
      for (uint64_t lB = B3_pos[kB]; lB < B3_pos[(kB + 1)]; lB++) {
        uint64_t l = B3_crd[lB];
        for (uint64_t j = 0; j < D2_dimension; j++) {
          uint64_t jA = i * A2_dimension + j;
          uint64_t jC = k * C2_dimension + j;
          uint64_t jD = l * D2_dimension + j;
          A_vals[jA] = A_vals[jA] + (B_vals[lB] * C_vals[jC]) * D_vals[jD];
        }
      }
    }
  }
}

#if defined(TEST_CORRECTNESS)
void test_correctness(taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *C, taco_tensor_t *D) {
  Format dd({Dense, Dense});
  Tensor<double> A_ref({A->dimensions[0], A->dimensions[1]}, dd);
  A_ref.pack();

  taco_tensor_t *A_ref_taco = A_ref.getTacoTensorT();
  assemble(A_ref_taco, A_ref_taco, A_ref_taco, A_ref_taco);

  int A1_dimension = (int)(A_ref_taco->dimensions[0]);
  int A2_dimension = (int)(A_ref_taco->dimensions[1]);
  double* __restrict__ A_vals = (double*)(A->vals);
  double* __restrict__ A_ref_taco_vals = (double*)(A_ref_taco->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int* __restrict__ B2_pos = (int*)(B->indices[1][0]);
  int* __restrict__ B2_crd = (int*)(B->indices[1][1]);
  int* __restrict__ B3_pos = (int*)(B->indices[2][0]);
  int* __restrict__ B3_crd = (int*)(B->indices[2][1]);
  double* __restrict__ B_vals = (double*)(B->vals);
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  double* __restrict__ C_vals = (double*)(C->vals);
  int D1_dimension = (int)(D->dimensions[0]);
  int D2_dimension = (int)(D->dimensions[1]);
  double* __restrict__ D_vals = (double*)(D->vals);

  // #pragma omp parallel for schedule(static)
  for (uint64_t pA = 0; pA < (A1_dimension * A2_dimension); pA++) {
    A_ref_taco_vals[pA] = 0.0;
  }

  MTTKRP_baseline(B1_dimension, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_ref_taco_vals, B_vals, C_vals, D_vals);

  uint64_t num_diffs = 0;
  double epsilon = 0.01;
  for (uint64_t i = 0; i < (A1_dimension * A2_dimension); i++) {
    auto diff = std::abs(A_vals[i] - A_ref_taco_vals[i]);
    if (diff > epsilon) {
      printf("diff=%f A_vals[i]=%f A_ref_taco_vals[i]=%f at i=%d\n", diff, A_vals[i], A_ref_taco_vals[i], i);
      num_diffs++;
    }
  }
  if (num_diffs > 0) {
    printf("\033[0;31mINCORRECT!\033[0m");
    printf("  num_diffs = %lu\n", num_diffs);
  } else {
    printf("\033[0;32mCORRECT!\033[0m\n");
  }
}
#endif
#endif

#if defined(USE_OPENMP)
void MTTKRP_openmp(
  int B1_dimension,
  int* __restrict__ B2_pos,
  int* __restrict__ B2_crd,
  int* __restrict__ B3_pos,
  int* __restrict__ B3_crd,
  int D2_dimension,
  int A2_dimension,
  int C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
#if defined(OMP_SCHEDULE_STATIC)
  #pragma omp parallel for schedule(static)
#elif defined(OMP_SCHEDULE_DYNAMIC)
  #pragma omp parallel for schedule(dynamic)
#elif defined(OMP_SCHEDULE_GUIDED)
  #pragma omp parallel for schedule(guided)
#endif
  for (uint64_t i = 0; i < B1_dimension; i++) {
    for (uint64_t kB = B2_pos[i]; kB < B2_pos[(i + 1)]; kB++) {
      uint64_t k = B2_crd[kB];
      for (uint64_t lB = B3_pos[kB]; lB < B3_pos[(kB + 1)]; lB++) {
        uint64_t l = B3_crd[lB];
        for (uint64_t j = 0; j < D2_dimension; j++) {
          uint64_t jA = i * A2_dimension + j;
          uint64_t jC = k * C2_dimension + j;
          uint64_t jD = l * D2_dimension + j;
          A_vals[jA] = A_vals[jA] + (B_vals[lB] * C_vals[jC]) * D_vals[jD];
        }
      }
    }
  }
}

#elif defined(USE_FORKJOIN)
void MTTKRP_serial(
  int startIter,
  int maxIter,
  int* __restrict__ B2_pos,
  int* __restrict__ B2_crd,
  int* __restrict__ B3_pos,
  int* __restrict__ B3_crd,
  int D2_dimension,
  int A2_dimension,
  int C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
  for (uint64_t i = startIter; i < maxIter; i++) {
    for (uint64_t kB = B2_pos[i]; kB < B2_pos[(i + 1)]; kB++) {
      uint64_t k = B2_crd[kB];
      for (uint64_t lB = B3_pos[kB]; lB < B3_pos[(kB + 1)]; lB++) {
        uint64_t l = B3_crd[lB];
        for (uint64_t j = 0; j < D2_dimension; j++) {
          uint64_t jA = i * A2_dimension + j;
          uint64_t jC = k * C2_dimension + j;
          uint64_t jD = l * D2_dimension + j;
          A_vals[jA] = A_vals[jA] + (B_vals[lB] * C_vals[jC]) * D_vals[jD];
        }
      }
    }
  }
}

void MTTKRP_forkjoin(
  int startIter,
  int maxIter,
  int* __restrict__ B2_pos,
  int* __restrict__ B2_crd,
  int* __restrict__ B3_pos,
  int* __restrict__ B3_crd,
  int D2_dimension,
  int A2_dimension,
  int C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
  if (maxIter - startIter > FORKJOIN_GRAIN_SIZE) {
    int midIter = (startIter + maxIter) / 2;
    taskparts::tpalrts_promote_via_nativefj([&] {
      MTTKRP_forkjoin(startIter, midIter, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
    }, [&] {
      MTTKRP_forkjoin(midIter, maxIter, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
    }, [&] { }, taskparts::bench_scheduler());
  } else {
    MTTKRP_serial(startIter, maxIter, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
  }
}

#elif defined(USE_HB_COMPILER)
#if PARALLEL_LEVEL >= 3
void HEARTBEAT_loop3(
  uint64_t i,
  uint64_t k,
  uint64_t l,
  uint64_t lB,
  uint64_t D2_dimension,
  uint64_t A2_dimension,
  uint64_t C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
  for (uint64_t j = 0; j < D2_dimension; j++) {
    uint64_t jA = i * A2_dimension + j;
    uint64_t jC = k * C2_dimension + j;
    uint64_t jD = l * D2_dimension + j;
    A_vals[jA] = A_vals[jA] + (B_vals[lB] * C_vals[jC]) * D_vals[jD];
  }
}
#endif

#if PARALLEL_LEVEL >= 2
void HEARTBEAT_loop2(
  uint64_t startIter,
  uint64_t maxIter,
  uint64_t i,
  uint64_t k,
  int* __restrict__ B3_crd,
  uint64_t D2_dimension,
  uint64_t A2_dimension,
  uint64_t C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
  for (uint64_t lB = startIter; lB < maxIter; lB++) {
    uint64_t l = B3_crd[lB];
#if PARALLEL_LEVEL == 2
    for (uint64_t j = 0; j < D2_dimension; j++) {
      uint64_t jA = i * A2_dimension + j;
      uint64_t jC = k * C2_dimension + j;
      uint64_t jD = l * D2_dimension + j;
      A_vals[jA] = A_vals[jA] + (B_vals[lB] * C_vals[jC]) * D_vals[jD];
    }
#else
    HEARTBEAT_loop3(i, k, l, lB, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
#endif
  }
}
#endif

#if PARALLEL_LEVEL >= 1
void HEARTBEAT_loop1(
  uint64_t startIter,
  uint64_t maxIter,
  uint64_t i,
  int* __restrict__ B2_crd,
  int* __restrict__ B3_pos,
  int* __restrict__ B3_crd,
  uint64_t D2_dimension,
  uint64_t A2_dimension,
  uint64_t C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
  for (uint64_t kB = startIter; kB < maxIter; kB++) {
    uint64_t k = B2_crd[kB];
#if PARALLEL_LEVEL == 1
    for (uint64_t lB = B3_pos[kB]; lB < B3_pos[(kB + 1)]; lB++) {
      uint64_t l = B3_crd[lB];
      for (uint64_t j = 0; j < D2_dimension; j++) {
        uint64_t jA = i * A2_dimension + j;
        uint64_t jC = k * C2_dimension + j;
        uint64_t jD = l * D2_dimension + j;
        A_vals[jA] = A_vals[jA] + (B_vals[lB] * C_vals[jC]) * D_vals[jD];
      }
    }
#else
    HEARTBEAT_loop2(B3_pos[kB], B3_pos[(kB + 1)], i, k, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
#endif
  }
}
#endif

void HEARTBEAT_loop0(
  uint64_t B1_dimension,
  int* __restrict__ B2_pos,
  int* __restrict__ B2_crd,
  int* __restrict__ B3_pos,
  int* __restrict__ B3_crd,
  uint64_t D2_dimension,
  uint64_t A2_dimension,
  uint64_t C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
  for (uint64_t i = 0; i < B1_dimension; i++) {
#if PARALLEL_LEVEL == 0
    for (uint64_t kB = B2_pos[i]; kB < B2_pos[(i + 1)]; kB++) {
      uint64_t k = B2_crd[kB];
      for (uint64_t lB = B3_pos[kB]; lB < B3_pos[(kB + 1)]; lB++) {
        uint64_t l = B3_crd[lB];
        for (uint64_t j = 0; j < D2_dimension; j++) {
          uint64_t jA = i * A2_dimension + j;
          uint64_t jC = k * C2_dimension + j;
          uint64_t jD = l * D2_dimension + j;
          A_vals[jA] = A_vals[jA] + (B_vals[lB] * C_vals[jC]) * D_vals[jD];
        }
      }
    }
#else
    HEARTBEAT_loop1(B2_pos[i], B2_pos[(i + 1)], i, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
#endif
  }
}

#if defined(RUN_HEARTBEAT)
  bool run_heartbeat = true;
#else
  bool run_heartbeat = false;
#endif

void MTTKRP_hbc(
  int B1_dimension,
  int* __restrict__ B2_pos,
  int* __restrict__ B2_crd,
  int* __restrict__ B3_pos,
  int* __restrict__ B3_crd,
  int D2_dimension,
  int A2_dimension,
  int C2_dimension,
  double* __restrict__ A_vals,
  double* __restrict__ B_vals,
  double* __restrict__ C_vals,
  double* __restrict__ D_vals
) {
  HEARTBEAT_loop0(B1_dimension, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
}

#elif defined(USE_HB_MANUAL)
#include "compute_hbm.hpp"
#endif

int compute(taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *C, taco_tensor_t *D) {
  int A1_dimension = (int)(A->dimensions[0]);
  int A2_dimension = (int)(A->dimensions[1]);
  double* __restrict__ A_vals = (double*)(A->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int* __restrict__ B2_pos = (int*)(B->indices[1][0]);
  int* __restrict__ B2_crd = (int*)(B->indices[1][1]);
  int* __restrict__ B3_pos = (int*)(B->indices[2][0]);
  int* __restrict__ B3_crd = (int*)(B->indices[2][1]);
  double* __restrict__ B_vals = (double*)(B->vals);
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  double* __restrict__ C_vals = (double*)(C->vals);
  int D1_dimension = (int)(D->dimensions[0]);
  int D2_dimension = (int)(D->dimensions[1]);
  double* __restrict__ D_vals = (double*)(D->vals);

  // #pragma omp parallel for schedule(static)
  for (uint64_t pA = 0; pA < (A1_dimension * A2_dimension); pA++) {
    A_vals[pA] = 0.0;
  }

#if defined(USE_BASELINE) || defined(USE_FORKJOIN)
  taskparts::benchmark_nativeforkjoin([&] (auto sched) {
#elif defined(USE_OPENMP)
  utility::run([&] {
#elif defined(USE_HB_COMPILER) || defined(USE_HB_MANUAL)
  run_bench([&] {
#endif

#if defined(USE_BASELINE)
    MTTKRP_baseline(B1_dimension, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
#elif defined(USE_OPENMP)
    MTTKRP_openmp(B1_dimension, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
#elif defined(USE_FORKJOIN)
    MTTKRP_forkjoin(0, B1_dimension, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
#elif defined(USE_HB_COMPILER)
    MTTKRP_hbc(B1_dimension, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
#elif defined(USE_HB_MANUAL)
    MTTKRP_hbm(B1_dimension, B2_pos, B2_crd, B3_pos, B3_crd, D2_dimension, A2_dimension, C2_dimension, A_vals, B_vals, C_vals, D_vals);
#endif

#if defined(TEST_CORRECTNESS)
    test_correctness(A, B, C, D);
#endif

#if defined(USE_BASELINE) || defined(USE_FORKJOIN)
  }, [&] (auto sched) {
  }, [&] (auto sched) {
  });
#else
  }, [&] {}, [&] {});
#endif

  return 0;
}
